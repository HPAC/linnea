import random

from matchpy import Arity

# Arity.nullary = Arity(0, True)
# Arity.unary = Arity(1, True)
# Arity.binary = Arity(2, True)
# Arity.ternary = Arity(3, True)
# Arity.polyadic = Arity(2, False)
# Arity.variadic = Arity(0, False)

from linnea.algebra import expression as ae
from linnea.algebra.transformations import simplify
from linnea.utils import window
from linnea.algebra.validity import check_validity
from linnea.algebra.properties import Property as properties

_counter = -1

def operand_size():
    return random.randrange(50, 2001, 50)

def operand_sizes():
    rand = random.random()
    if rand > 0.6:
        # square
        n = operand_size()
        sizes = (n, n)
    elif rand > 0.3:
        # rectangular
        n = operand_size()
        m = operand_size()
        sizes = (n, m)
    else:
        # vector
        n = operand_size()
        sizes = (n, 1)
    return sizes

def generate_scalar():
    global _counter
    _counter += 1
    return ae.Scalar("s{}".format(_counter))

def generate_vector(rows):
    global _counter
    _counter += 1
    return ae.Vector("v{}".format(_counter), (rows, 1))

def generate_matrix(rows, columns):
    global _counter
    _counter += 1
    operand = ae.Matrix("M{}".format(_counter), (rows, columns))
    operand.set_property(properties.FULL_RANK)  
    if rows == columns and random.random() > 0.25:
        operand.set_property(random.choice([properties.DIAGONAL, properties.LOWER_TRIANGULAR, properties.UPPER_TRIANGULAR, properties.SYMMETRIC, properties.SPD]))
    return operand

def matrix_chain_sizes(first, last, length, nonsingular=False):
    """Generates operand sizes for a matrix chain.

    For a chain of length n, n+1 operand sizes are necessary. To create
    realistic chains with square matrices, there is a chance that the returned
    list contains repetitions.

    Args:
        first (int): The number or rows of the matrix chain expression.
        last (int): The number of columns of the matrix chain expression.
        length (int): The number of matrices in the chain.
        nonsingular (bool): Wheather the chain has to be nonsingular/invertible.

    Returns:
        list: A list [first, ..., last] with length+1 values.
    """
    sizes = [first]
    for i in range(length-1):
        rand = random.random()
        if rand > 0.65: # 0.6 <= rand < 0.95:
            # square
            next_size = sizes[i]
        elif rand > 0.55: # 0.95 <= rand:
            # vector
            next_size = 1
        else:
            # non-square
            next_size = operand_size()

        if nonsingular and next_size < min(first, last):
            # This makes sure that the resulting chain is not singular. That
            # would happen if an "inner size" is smaller than an "outer size".
            next_size = min(first, last)
        
        sizes.append(next_size)

    sizes.append(last)

    return sizes


def random_composition(n):
    """Generatas a radnom composition of n.
    
    A composition is an ordered sum of positive integers. This function always
    generates a composition with at least two elements.

    We make use of the fact that each composition of n can be represented by a
    sequence of n-1 bits. Example for n=5:
    0000    5 (not generated by this function)
    0001    4+1
    0111    2+1+1+1
    1000    1+4
    1011    1+2+1+1
    1111    1+1+1+1+1
    
    See also http://oeis.org/wiki/Integer_compositions#Number_of_compositions
    """
    num = random.randint(1, 2**(n-1)-1)
    bitseq = bin(num)[2:].zfill(n-1)
    composition = [1]
    for bit in bitseq:
        if bit == "0":
            composition[-1] += 1
        elif bit == "1":
            composition.append(1)
    return composition


def generate_expression(n_ops, expr_size, parent=None, nonsingular=False):
    if n_ops == 1:

        rows, columns = expr_size
        if columns == rows:
            if rows == 1:
                return generate_scalar()
            
            if random.random() > 0.5:       
                operators = [ae.Transpose, ae.Inverse]
                try:
                    operators.remove(parent)
                except ValueError:
                    pass
                operator = random.choice(operators)
                return operator(generate_matrix(columns, rows))

            return generate_matrix(rows, columns)

        elif columns == 1:
            return generate_vector(rows)
        elif rows == 1:
            return ae.Transpose(generate_vector(columns))
        else:
            if parent != ae.Transpose and random.random() > 0.5:
                return ae.Transpose(generate_matrix(columns, rows))
            else:
                return generate_matrix(rows, columns)


    else:
        # TODO do we really want to use transpose here? it get's pushed down anyway, and it leads to those towers
        if expr_size[0] == expr_size[1]:
            # operators = [ae.Times, ae.Plus, ae.Transpose, ae.Inverse]
            operators = [ae.Times, ae.Plus, ae.Inverse]

            """Trying to tweak probabilities to get more realistic expressions.
            Mostly trying to avoid explicit inversion, which is rare.

            TODO Perhaps instead of changing those list, we should just
            construct population and weights list for random.choices
            """
            if parent is ae.Times:
                operators.append(ae.Inverse)
            elif parent is ae.Plus:
                operators.append(ae.Times)
            elif parent is None:
                operators.append(ae.Times)
                operators.append(ae.Plus)
        else:
            # operators = [ae.Times, ae.Plus, ae.Transpose]
            operators = [ae.Times, ae.Plus]

        try:
            operators.remove(parent)
        except ValueError:
            pass

        operator = random.choice(operators)
        if operator.arity == Arity.unary:
            # flip size here
            if operator is ae.Inverse:
                nonsingular = True
            expr = operator(generate_expression(n_ops, tuple(reversed(expr_size)), parent=operator, nonsingular=nonsingular))
            return expr
        elif operator.arity == Arity.variadic:
            partition = random_composition(n_ops)
            if operator == ae.Plus:
                expr = operator(*(generate_expression(n, expr_size, parent=operator, nonsingular=nonsingular) for n in partition))
            elif operator == ae.Times:
                sizes = matrix_chain_sizes(*expr_size, len(partition), nonsingular=nonsingular)
                operands = []
                for n, size in zip(partition, window(sizes)):
                    operands.append(generate_expression(n, size, parent=operator, nonsingular=nonsingular))

                expr = operator(*operands)
            return expr


def main():
    expr_size = operand_sizes()
    expr = generate_expression(6, expr_size)
    print(expr)
    print(simplify(expr))
    print(check_validity(expr))
    # print(random_composition(5))
    # print(matrix_chain_sizes(10, 1000, 4))

"""
What is happening here?
(M0 (M1 + M2)^-1)^-1
((M1 + M2) M0^-1 (M0 (M1 + M2)^-1)^-1 (M1 + M2) M0^-1)
"""

if __name__ == '__main__':
    main()