import random

from matchpy import Arity

# Arity.nullary = Arity(0, True)
# Arity.unary = Arity(1, True)
# Arity.binary = Arity(2, True)
# Arity.ternary = Arity(3, True)
# Arity.polyadic = Arity(2, False)
# Arity.variadic = Arity(0, False)

from linnea.algebra import expression as ae
from linnea.algebra import equations as aeq
from linnea.algebra.transformations import simplify
from linnea.utils import window
from linnea.algebra.validity import check_validity
from linnea.algebra.properties import Property as properties

_counter = -1

def operand_size():
    return random.randrange(50, 2001, 50)

def operand_sizes():
    rand = random.random()
    if rand > 0.5:
        # square
        n = operand_size()
        sizes = (n, n)
    elif rand > 0.10:
        # rectangular
        n = operand_size()
        m = operand_size()
        sizes = (n, m)
    else:
        # vector
        n = operand_size()
        sizes = (n, 1)
    return sizes

def generate_scalar():
    global _counter
    _counter += 1
    return ae.Scalar("s{}".format(_counter))

def generate_vector(rows):
    global _counter
    _counter += 1
    return ae.Vector("v{}".format(_counter), (rows, 1))

def generate_matrix(rows, columns):
    global _counter
    _counter += 1
    operand = ae.Matrix("M{}".format(_counter), (rows, columns))
    operand.set_property(properties.FULL_RANK)  
    if rows == columns and random.random() > 0.25:
        operand.set_property(random.choice([properties.DIAGONAL, properties.LOWER_TRIANGULAR, properties.UPPER_TRIANGULAR, properties.SYMMETRIC, properties.SPD]))
    return operand

def matrix_chain_sizes(first, last, length, nonsingular=False):
    """Generates operand sizes for a matrix chain.

    For a chain of length n, n+1 operand sizes are necessary. To create
    realistic chains with square matrices, there is a chance that the returned
    list contains repetitions.

    Args:
        first (int): The number or rows of the matrix chain expression.
        last (int): The number of columns of the matrix chain expression.
        length (int): The number of matrices in the chain.
        nonsingular (bool): Wheather the chain has to be nonsingular/invertible.

    Returns:
        list: A list [first, ..., last] with length+1 values.
    """
    sizes = [first]
    for i in range(length-1):
        rand = random.random()
        if rand > 0.5: # 0.6 <= rand < 0.95:
            # square
            next_size = sizes[i]
        elif rand > 0.4: # 0.95 <= rand:
            # vector
            next_size = 1
        else:
            # non-square
            next_size = operand_size()

        if nonsingular and next_size < min(first, last):
            # This makes sure that the resulting chain is not singular. That
            # would happen if an "inner size" is smaller than an "outer size".
            next_size = min(first, last)
        
        sizes.append(next_size)

    sizes.append(last)

    return sizes


def random_composition(n):
    """Generatas a radnom composition of n.
    
    A composition is an ordered sum of positive integers. This function always
    generates a composition with at least two elements.

    We make use of the fact that each composition of n can be represented by a
    sequence of n-1 bits. Example for n=5:
    0000    5 (not generated by this function)
    0001    4+1
    0111    2+1+1+1
    1000    1+4
    1011    1+2+1+1
    1111    1+1+1+1+1
    
    See also http://oeis.org/wiki/Integer_compositions#Number_of_compositions
    """
    num = random.randint(1, 2**(n-1)-1)
    bitseq = bin(num)[2:].zfill(n-1)
    composition = [1]
    for bit in bitseq:
        if bit == "0":
            composition[-1] += 1
        elif bit == "1":
            composition.append(1)
    return composition


def generate_expression(n_ops, expr_size, parent=None, nonsingular=False):
    if n_ops == 1:

        rows, columns = expr_size
        if columns == rows:
            if rows == 1:
                return generate_scalar()
            
            if random.random() > 0.5:

                if parent.arity == Arity.unary:
                    if parent is ae.Inverse:
                        operator = ae.Transpose
                    elif parent is ae.Transpose:
                        operator = ae.Inverse    
                else:
                    operators = [ae.Transpose, ae.Inverse]
                    if parent is ae.Plus:
                        weights = [2, 1]
                    else:
                        weights = [1, 3]

                    operator = random.choices(operators, weights)[0]

                return operator(generate_matrix(columns, rows))

            return generate_matrix(rows, columns)

        elif columns == 1:
            return generate_vector(rows)
        elif rows == 1:
            return ae.Transpose(generate_vector(columns))
        else:
            if parent != ae.Transpose and random.random() > 0.5:
                return ae.Transpose(generate_matrix(columns, rows))
            else:
                return generate_matrix(rows, columns)


    else:
        # TODO do we really want to use transpose here? it get's pushed down anyway, and it leads to those towers
        if expr_size[0] == expr_size[1]:
            # operators = [ae.Times, ae.Plus, ae.Transpose, ae.Inverse]

            """Trying to tweak probabilities to get more realistic expressions.
            Mostly trying to avoid explicit inversion, which is rare.
            """
            if parent is ae.Times:
                operators = [ae.Plus, ae.Inverse]
                weights = [1, 4]
            elif parent is ae.Plus:
                operators = [ae.Times, ae.Inverse]
                weights = [4, 1]
            elif parent is ae.Inverse:
                operators = [ae.Times, ae.Plus]
                weights = [3, 1]    
            elif parent is None:
                operators = [ae.Times, ae.Plus, ae.Inverse]
                weights = [5, 3, 1]
        else:
            # operators = [ae.Times, ae.Plus, ae.Transpose]
            operators = [ae.Times, ae.Plus]
            weights = [3, 1]


        operator = random.choices(operators, weights)[0]
        if operator.arity == Arity.unary:
            # flip size here
            if operator is ae.Inverse:
                nonsingular = True
            expr = operator(generate_expression(n_ops, tuple(reversed(expr_size)), parent=operator, nonsingular=nonsingular))
            return expr
        elif operator.arity == Arity.variadic:
            partition = random_composition(n_ops)
            if operator == ae.Plus:
                expr = operator(*(generate_expression(n, expr_size, parent=operator, nonsingular=nonsingular) for n in partition))
            elif operator == ae.Times:
                sizes = matrix_chain_sizes(*expr_size, len(partition), nonsingular=nonsingular)
                operands = []
                for n, size in zip(partition, window(sizes)):
                    operands.append(generate_expression(n, size, parent=operator, nonsingular=nonsingular))

                expr = operator(*operands)
            return expr


def generate_equation(n_ops):
    expr_size = operand_sizes()
    out = ae.Matrix("out", expr_size)
    expr = simplify(generate_expression(n_ops, expr_size))
    return aeq.Equations(ae.Equal(out, expr))


def main():
    # expr_size = operand_sizes()
    # expr = generate_expression(6, expr_size)
    # print(expr)
    # print(simplify(expr))
    # print(check_validity(expr))

    size = random.randint(3, 7)
    eqn = generate_equation(size)
    print(eqn)
    # eqn = eqn.to_normalform()
    # print(eqn)
    print(check_validity(eqn))


"""
What is happening here?
(M0 (M1 + M2)^-1)^-1
((M1 + M2) M0^-1 (M0 (M1 + M2)^-1)^-1 (M1 + M2) M0^-1)
"""

if __name__ == '__main__':
    main()