import random

from matchpy import Arity

# Arity.nullary = Arity(0, True)
# Arity.unary = Arity(1, True)
# Arity.binary = Arity(2, True)
# Arity.ternary = Arity(3, True)
# Arity.polyadic = Arity(2, False)
# Arity.variadic = Arity(0, False)

from linnea.algebra import expression as ae
from linnea.algebra import equations as aeq
from linnea.algebra.transformations import simplify
from linnea.utils import window
from linnea.algebra.validity import check_validity
from linnea.algebra.properties import Property as properties

_counter = -1

def operand_size(lower=50):
    return random.randrange(lower, 2001, 50)

def operand_sizes():
    rand = random.random()
    if rand > 0.5:
        # square
        n = operand_size()
        sizes = (n, n)
    elif rand > 0.10:
        # rectangular
        n = operand_size()
        m = operand_size()
        sizes = (n, m)
    else:
        # vector
        n = operand_size()
        sizes = (n, 1)
    return sizes

def generate_scalar():
    global _counter
    _counter += 1
    return ae.Scalar("s{}".format(_counter))

def generate_vector(rows):
    global _counter
    _counter += 1
    return ae.Vector("v{}".format(_counter), (rows, 1))

def generate_matrix(rows, columns):
    global _counter
    _counter += 1
    operand = ae.Matrix("M{}".format(_counter), (rows, columns))
    operand.set_property(properties.FULL_RANK)  
    if rows == columns and random.random() > 0.25:
        operand.set_property(random.choice([properties.DIAGONAL, properties.LOWER_TRIANGULAR, properties.UPPER_TRIANGULAR, properties.SYMMETRIC, properties.SPD]))
    return operand

def matrix_chain_sizes(first, last, length, nonsingular=False):
    """Generates operand sizes for a matrix chain.

    For a chain of length n, n+1 operand sizes are necessary. To create
    realistic chains with square matrices, there is a chance that the returned
    list contains repetitions.

    Args:
        first (int): The number or rows of the matrix chain expression.
        last (int): The number of columns of the matrix chain expression.
        length (int): The number of matrices in the chain.
        nonsingular (bool): Wheather the chain has to be nonsingular/invertible.

    Returns:
        list: A list [first, ..., last] with length+1 values.
    """
    sizes = [first]
    for i in range(length-1):
        rand = random.random()
        if nonsingular:
            if rand > 1:
                # square
                next_size = sizes[i]
            else:
                # non-square
                # This makes sure that the resulting chain is not singular. That
                # would happen if an "inner size" is smaller than an "outer size".
                next_size = operand_size(lower=min(first, last))
        else:
            if rand > 0.4:
                # square
                next_size = sizes[i]
            elif rand > 0.38:
                # vector
                next_size = 1
            else:
                # non-square
                next_size = operand_size()
        
        sizes.append(next_size)

    sizes.append(last)

    return sizes


def random_composition(n):
    """Generatas a random composition of n.
    
    A composition is an ordered sum of positive integers. This function always
    generates a composition with at least two elements.

    We make use of the fact that each composition of n can be represented by a
    sequence of n-1 bits. Example for n=5:
    0000    5 (not generated by this function)
    0001    4+1
    0111    2+1+1+1
    1000    1+4
    1011    1+2+1+1
    1111    1+1+1+1+1
    
    See also http://oeis.org/wiki/Integer_compositions#Number_of_compositions
    """
    num = random.randint(1, 2**(n-1)-1)
    bitseq = bin(num)[2:].zfill(n-1)
    composition = [1]
    for bit in bitseq:
        if bit == "0":
            composition[-1] += 1
        elif bit == "1":
            composition.append(1)
    return composition


def random_composition_v2(n):
    if n == 2:
        return [1, 1]
    else:  
        num = random.randint(1, 2**(n-1)-2)
        bitseq = bin(num)[2:].zfill(n-1)
        composition = [1]
        for bit in bitseq:
            if bit == "0":
                composition[-1] += 1
            elif bit == "1":
                composition.append(1)
        return composition


def generate_expression(n_ops, expr_size, parent=None, nonsingular=False):
    if n_ops == 1:

        rows, columns = expr_size
        if columns == rows:
            if rows == 1:
                return generate_scalar()
            
            if random.random() > 0.2:

                if parent.arity == Arity.unary:
                    if parent is ae.Inverse:
                        operator = ae.Transpose
                    elif parent is ae.Transpose:
                        operator = ae.Inverse    
                else:
                    operators = [ae.Transpose, ae.Inverse]
                    if parent is ae.Plus:
                        weights = [10, 1]
                    else:
                        weights = [1, 10]

                    operator = random.choices(operators, weights)[0]

                return operator(generate_matrix(columns, rows))

            return generate_matrix(rows, columns)

        elif columns == 1:
            return generate_vector(rows)
        elif rows == 1:
            return ae.Transpose(generate_vector(columns))
        else:
            if parent != ae.Transpose and random.random() > 0.5:
                return ae.Transpose(generate_matrix(columns, rows))
            else:
                return generate_matrix(rows, columns)


    else:
        if n_ops <= 5 and expr_size[0] == expr_size[1] and random.random() > 0.9:
            if n_ops % 2 == 0:
                if nonsingular:
                    inner_size = operand_size(lower=expr_size[0])
                else:
                    inner_size = operand_size()
                expr = generate_expression(n_ops // 2, (expr_size[0], inner_size), parent=ae.Plus, nonsingular=nonsingular)
                return ae.Times(expr, ae.Transpose(expr))
            else:
                if nonsingular:
                    inner_size = operand_size(lower=expr_size[0])
                else:
                    inner_size = operand_size()
                expr = generate_expression(n_ops // 2, (expr_size[0], inner_size), parent=ae.Plus, nonsingular=nonsingular)
                expr_center = generate_expression(1, (inner_size, inner_size), parent=ae.Plus, nonsingular=nonsingular)
                return ae.Times(expr, expr_center, ae.Transpose(expr))


        if expr_size[0] == expr_size[1]:
            """Trying to tweak probabilities to get more realistic expressions.
            Mostly trying to avoid explicit inversion, which is rare.
            """
            if parent is ae.Times:
                operators = [ae.Plus, ae.Inverse]
                weights = [1, 4]
            elif parent is ae.Plus:
                operators = [ae.Times, ae.Inverse]
                weights = [4, 1]
            elif parent is ae.Inverse:
                operators = [ae.Times, ae.Plus]
                weights = [2, 1]    
            elif parent is None:
                operators = [ae.Times, ae.Plus, ae.Inverse]
                weights = [16, 10, 1]
        else:
            if parent is ae.Times:
                operators = [ae.Plus]
                weights = [1]
            elif parent is ae.Plus:
                operators = [ae.Times]
                weights = [1]
            else:
                operators = [ae.Times, ae.Plus]
                weights = [3, 1]


        operator = random.choices(operators, weights)[0]
        if operator.arity == Arity.unary:
            # flip size here
            if operator is ae.Inverse:
                nonsingular = True
            expr = operator(generate_expression(n_ops, tuple(reversed(expr_size)), parent=operator, nonsingular=nonsingular))
            return expr
        elif operator.arity == Arity.variadic:
            # partition = random_composition(n_ops)
            partition = random_composition_v2(n_ops)
            if operator == ae.Plus:
                expr = operator(*(generate_expression(n, expr_size, parent=operator, nonsingular=nonsingular) for n in partition))
            elif operator == ae.Times:
                sizes = matrix_chain_sizes(*expr_size, len(partition), nonsingular=nonsingular)
                operands = []
                for n, size in zip(partition, window(sizes)):
                    operands.append(generate_expression(n, size, parent=operator, nonsingular=nonsingular))

                expr = operator(*operands)
            return expr


def generate_equation(n_ops):
    expr_size = operand_sizes()
    out = ae.Matrix("out", expr_size)
    expr = simplify(generate_expression(n_ops, expr_size))
    return aeq.Equations(ae.Equal(out, expr))


def main():
    # expr_size = operand_sizes()
    # expr = generate_expression(6, expr_size)
    # print(expr)
    # print(simplify(expr))
    # print(expr.check_validity())

    # size = random.randint(3, 7)
    # eqn = generate_equation(size)
    # print(eqn)
    # # eqn = eqn.to_normalform()
    # # print(eqn)
    # print(eqn.check_validity())

    random.seed(0)
    rand_exprs = [generate_equation(random.randint(4, 7)) for _ in range(100)]
    i = 0
    no_full_matrix = 0
    no_inverse = 0
    result_is_vector = 0
    contains_scalars = 0
    no_square_matrix = 0
    no_non_square_matrix = 0
    for idx, eqn in enumerate(rand_exprs, 1):
        if not any((isinstance(subexpr, ae.Matrix) and not subexpr.has_property(properties.DIAGONAL)) for subexpr, _ in eqn[0].rhs.preorder_iter()):
        #     print(idx, eqn)
            no_full_matrix += 1

        if not any((isinstance(subexpr, ae.Inverse) or isinstance(subexpr, ae.InverseTranspose)) for subexpr, _ in eqn[0].rhs.preorder_iter()):
            # print(idx, eqn)
            no_inverse += 1

        if eqn[0].rhs.has_property(properties.VECTOR):
            # print(idx, eqn)
            result_is_vector += 1

        non_square = 0
        square = 0
        for subexpr, _ in eqn[0].rhs.preorder_iter():
            if isinstance(subexpr, ae.Matrix) and not subexpr.has_property(properties.SQUARE):
                non_square += 1
                # print(subexpr.size)
            else:
                square += 1
        if not square:
            no_square_matrix += 1
        if not non_square:
            no_non_square_matrix += 1



        print(idx, eqn)
        # print("non_square", non_square)

        if any(isinstance(subexpr, ae.Scalar) for subexpr, _ in eqn[0].rhs.preorder_iter()):
            contains_scalars += 1

    print("############")
    print("no_full_matrix", no_full_matrix)
    print("no_inverse", no_inverse)
    print("result_is_vector", result_is_vector)
    print("contains_scalars", contains_scalars)
    print("no_square_matrix", no_square_matrix)
    print("no_non_square_matrix", no_non_square_matrix)


"""
What is happening here?
(M0 (M1 + M2)^-1)^-1
((M1 + M2) M0^-1 (M0 (M1 + M2)^-1)^-1 (M1 + M2) M0^-1)
"""

if __name__ == '__main__':
    main()